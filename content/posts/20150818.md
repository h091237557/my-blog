---
title: "物件導向系列菜單 3 -『 物件導向特性-繼承 ( Inheritance ) 2- Virtual 與 Override 』"
date: 2015-08-18T19:51:35+08:00
draft: false
categories:
tags: 
- c井字號
- 物件導向
keywords:
- 測試
- c#
- 物件導向
- oo
---


## Virtual 修飾詞

> 子類別的方法名稱和父類別的方法名稱一樣，著麼辦呢 ?

virtual 關鍵字的用途是修改方法、屬性或事件宣告，以及`允許在衍生類別中給予覆寫`。通常使用的時機是在未來預期該方法可能會被子類別覆寫(override)，則此方法必須宣告Virtual。

```c#
	 //父類別
    public class Car
    {

        //車子的速度
        public string Speed;
        //車子的顏色
        public string Color;

        // 定義建構子，預設Speed為50，Color為Blue
        public  Car()
        {
            Speed = "50";
            Color = "Blue";
        }

        //定義車子移動的方法。
        //在該方法加上Virtual，讓子類別可以覆寫該方法。
        public virtual string DriveCar()
        {
            return "正在開『" + Color + "』的車" + "時速『" + Speed + "』在移動" ;
        }

    }
```

## Override 修飾詞

Overrride修飾詞為需要用來修改或擴充父類別的方法、屬性，則需要給予該方法或屬性進行宣告。

```c#
 	// 子類別繼承Car
    public class BMWCar :Car
    {
        //BMWCar類別建構子
        public BMWCar()
        {
            Speed = "BMW500";
            Color = "BWM_Red";
        }

        //BMW的屬性引擎
        public string BMWPower;

        //定義車子移動的方法
        //使用存取修飾詞Overried，來進行覆寫
        public override string DriveCar()
        {
            return "正在開『" + Color + "』的車" + "時速『" + Speed + "』在移動" + "『Override』" ;
        }

    }
    
    執行結果
    正在開『BMW_Red』的車時速『BWM500』在移動『Override』
```

## Override 修飾詞特性


### 注意 1 
你不能覆寫`非虛擬`或`靜態方法`。被覆寫的父類別方法必須是`Virtual`、`abstract`、`Override`。

### 注意 2 

`override` 方法和 `virtual` 方法都必須有相同的存取層級修飾詞。

```c#
       //定義車子移動的方法。
       //在該方法加上Virtual，讓子類別可以覆寫該方法。
        public virtual string DriveCar()
        {
            return "正在開『" + Color + "』的車" + "時速『" + Speed + "』在移動" ;
        }

       //定義車子移動的方法
        //使用存取修飾詞Overried，來進行覆寫
        protected  override string DriveCar()
        {
            return "正在開『" + Color + "』的車" + "時速『" + Speed + "』在移動" + "『Override』" ;
        }

如果將BMWCar類別程式碼其的DriveCar()方法改為 protected 則會出錯。
```

### 注意 3

如果是覆寫『屬性』時，則以下有兩項條件

* 覆寫屬性宣告必須指定和所繼承屬性完全相同的存取修飾詞、型別和名稱。
* 且被覆寫的屬性必須是 virtual、abstract 或 override。

### 注意 4
如果方法是在類別指定，而在呼叫的類別有兩個方法相容，則C#編譯器會自動呼叫最適合的方法。

我們將BMWCar 類別改為如下。

```c#
	// 子類別繼承Car
   	 public class BMWCar :Car
    {
        //BMWCar類別建構子
        public BMWCar()
        {
            Speed = "BMW500";
            Color = "BWM_Red";
        }

        //BMW的屬性引擎
        public string BMWPower;

        //定義車子移動的方法
        //使用存取修飾詞Overried，來進行覆寫
        //參數a 為 string
        public   override string DriveCar( string a)
        {
            return "正在開『" + Color + "』的車" + "時速『" + Speed + "』在移動" + "『Override』" + "String--" + a;
        }

        //參數a 為 int
        public string DriveCar(int a)
        {
            return "正在開『" + Color + "』的車" + "時速『" + Speed + "』在移動" + "『Override』" + "Int--" + a  ;
        }

    }
```

然後實體化並呼叫DriveCar方法。

```c#
    int a = 1;
    //string a = "Hello" ;
    BMWCar MyBMWCar = new BMWCar();
    TextBox1.Text = MyBMWCar.DriveCar(a) ;
```

則執行結果為如下，會自動呼叫`public override string DriveCar(int a)`，
因為編輯器會自動幫我們選擇最適合的方法。

```
	正在開『BWM_Red』 的車時速『BWM500』在移動「Override』int--1
```

而如果實體化並呼叫DriveCar改為
	
```c#
	//int a = 1;
   	string a = "Hello";
    BMWCar MyBMWCar = new BMWCar();
    TextBox1.Text = MyBMWCar.DriveCar(a) ;
```

則執行結果為如下。

```
	正在開『BWM_Red』 的車時速『BWM500』在移動「Override』String--Hello
```

## 參考文章

* http://www.dotblogs.com.tw/skychang/archive/2012/05/10/72114.aspx?fid=60865
* http://msdn.microsoft.com/zh-tw/library/6fawty39.aspx
* http://msdn.microsoft.com/zh-tw/library/ebca9ah3.aspx
* http://msdn.microsoft.com/zh-tw/library/9fkccyh4.aspx
* http://www.dotnetperls.com/virtual
